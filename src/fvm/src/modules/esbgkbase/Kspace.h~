#ifndef _KSPACE_H_
#define _KSPACE_H_

#include <vector>
#include <math.h>
#include "Vector.h"
#include "pmode.h"
#include "kvol.h"

template<class T>
class Kspace
{

 public:

  typedef Vector<T,3> Tvec;
  typedef pmode<T> Tmode;
  typedef kvol<T> Tkvol;
  typedef vector<Tkvol*> Volvec;

  Kspace(int n,int modenum) 
    {
      _length=n;
      for (int i=0;i<n;i++)
	{_Kmesh.push_back(new Tkvol(modenum));}
    }

  Kspace(T tau,T vgmag,T cp,int ntheta,int nphi)  
    { //makes gray, isotropic kspace  
 
      _length=0;
      _Kmesh=*(new Volvec);
      const double pi=3.141592653;
      T theta;
      T phi;
      T dtheta=pi/ntheta;
      T dphi=2.*pi/nphi;
      T dk3;
      Tvec vg;
      for(int t=0;t<ntheta;t++)
	{
	  theta=dtheta*(t+.5);
	  for(int p=0;p<nphi;p++)
	    {
	      _length+=1;
	      phi=dphi*(p+.5);
	      vg[0]=vgmag*cos(theta)*sin(phi);
	      vg[1]=vgmag*cos(theta)*cos(phi);
	      vg[2]=vgmag*sin(theta);
	      dk3=2.*sin(theta)*sin(dtheta/2.)*dphi;
	      Tmode* mode=new Tmode(vg,cp,tau);
	      Tkvol* vol=new Tkvol(mode,dk3);
	      _Kmesh.push_back(vol); 
	    }
	}     
    }

  void setvol(int n,Tkvol k) {*_Kmesh[n]=k;}
  Tkvol getkvol(int n) {return *_Kmesh[n];}
  Tkvol* getkvolptr(int n) const {return _Kmesh[n];}
  int getlength() const {return _length;}
  int gettotmodes()
  {
    return (_Kmesh[0]->getmodenum())*_length;
  }
  void findDK3()
  {
    _totvol=0.;
    for(int i=0;i<_length;i++)
      {
	Tkvol vol=getkvol(i);
	_totvol+=vol.getdk3();
      }
  }
  T getDK3() const {return _totvol;}

 private:

  //number of volumes
  int _length;
  Volvec _Kmesh;
  T _totvol;    //total Kspace volume
  

};


#endif
